(defn update-quality [items]
  (map
    (fn[item] (cond
      ; if sell-in is less than 0 and item is backstage passes
      (and (< (:sell-in item) 0) (= "Backstage passes to a TAFKAL80ETC concert" (:name item)))
        ; quality = 0
        (merge item {:quality 0})
      ; if item is aged brie or backstage passes
      (or (= (:name item) "Aged Brie") (= (:name item) "Backstage passes to a TAFKAL80ETC concert"))
        ; if item is backstage passes and sell-in is between 5 and 9
        (if (and (= (:name item) "Backstage passes to a TAFKAL80ETC concert") (>= (:sell-in item) 5) (< (:sell-in item) 10))
          ; quality increases by 2
          (merge item {:quality (inc (inc (:quality item)))})
          ; else if item is backstage passes and sell-in is between 0 and 4
          (if (and (= (:name item) "Backstage passes to a TAFKAL80ETC concert") (>= (:sell-in item) 0) (< (:sell-in item) 5))
            ; quality increases by 3
            (merge item {:quality (inc (inc (inc (:quality item))))})
            ; else if item quality is less than 50
            (if (< (:quality item) 50)
              ; quality increases by 1
              (merge item {:quality (inc (:quality item))})
              item)))
      ; if item sell-in is less than 0
      (< (:sell-in item) 0)
        ; if item is backstage passes
        (if (= "Backstage passes to a TAFKAL80ETC concert" (:name item))
          ; qualty = 0
          (merge item {:quality 0})
          ; if item is dexterity vest or elixir of the mongoose
          (if (or (= "+5 Dexterity Vest" (:name item)) (= "Elixir of the Mongoose" (:name item)))
            ; quality decreases by 2
            (merge item {:quality (- (:quality item) 2)})
            item))
      ; if item is exterity vest or elixr of the mongoose
      (or (= "+5 Dexterity Vest" (:name item)) (= "Elixir of the Mongoose" (:name item)))
        ;quality decreases by 1
        (merge item {:quality (dec (:quality item))})
      ; for all other items
      :else item))
  (map (fn [item]
    not sulfuras
      (if (not= "Sulfuras, Hand of Ragnaros" (:name item))
        ; decrease sell-in
        (merge item {:sell-in (dec (:sell-in item))})
        item))
  ; return items
  items)))
; item has a name, sell-in, and quality
(defn item [item-name, sell-in, quality]
  {:name item-name, :sell-in sell-in, :quality quality})
; starting values for inventory
(defn update-current-inventory[]
  (let [inventory
    [
      (item "+5 Dexterity Vest" 10 20)
      (item "Aged Brie" 2 0)
      (item "Elixir of the Mongoose" 5 7)
      (item "Sulfuras, Hand Of Ragnaros" 0 80)
      (item "Backstage passes to a TAFKAL80ETC concert" 15 20)
    ]]
    (update-quality inventory)
    ))
(let [updated-inventory (update-current-inventory)]
      (let [
        dexterity-vest (nth updated-inventory 0)
        aged-brie (nth updated-inventory 1) elixir-mongoose (nth updated-inventory 2)
        sulfuras (nth updated-inventory 3) backstage-passes (nth updated-inventory 4)]))
:quit
quit
(defn item [item-name, sell-in, quality]
  {:name item-name, :sell-in sell-in, :quality quality})
(defmulti update-sell-in :Item)
(defmethod update-sell-in :default [item]
  (assoc item :sell-in (dec (:sell-in item))))
(defmulti update-quality :Item)
(defmethod update-quality :default [item]
  (assoc item :quality (dec (:quality item))))
(defn update [items]
  (map (comp update-sell-in update-quality)))
(item "Default" 10 10 )
(:sell-in item)
(def default (item "Default" 10 10)
)
(:sell-in default)
(update-sell-in default)
(:sell-in default)
default
(defmethod update-sell-in :default [item]
  (merge item {:sell-in (dec (:sell-in item))}))
(update-sell-in default)
default
(def default (update-sell-in default))
default
quit
(defn item [item-name, sell-in, quality]
  {:name item-name, :sell-in sell-in, :quality quality})
(defmulti update-sell-in :Item)
(defmethod update-sell-in :default [item]
  (assoc item :sell-in (dec (:sell-in item))))
(defmulti update-quality :Item)
(defmethod update-quality :default [item]
  (assoc item :quality (dec (:quality item))))
(defn update [items]
  (map (comp update-sell-in update-quality)))
(let [default-item (item "Default Item" 10 20)]
(let [updated-item (update-quality default-item)]
(:sell-in updated-item)
)
(let [default-item (item "Default Item" 10 20)]
(let [updated-item (update-sell-in default-item)]
(:sell-in updated-item)))
quit
(defn item [item-name, sell-in, quality]
  {:name item-name, :sell-in sell-in, :quality quality})
(defmulti update-sell-in :Item)
(defmethod update-sell-in :default [item]
  (merge item {:sell-in (dec (:sell-in item))}))
(defmulti update-quality :Item)
(defmethod update-quality :default [item]
  (merge item {:quality (dec (:quality item))}))
(let [updated-item (update-sell-in default-item)]
(= (:sell-in updated-item) 9))
(let [default-item (item "Default Item" 10 20)]
(let [updated-item (update-quality default-item)]
(= (:quality updated-item) 19)))
quit
